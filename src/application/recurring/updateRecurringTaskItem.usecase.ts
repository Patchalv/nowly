import type { Task } from '@/src/domain/model/Task';
import type { UpdateRecurringTaskItemInput } from '@/src/domain/validation/recurring/recurringTaskItem.schema';
import type { IRecurringTaskItemRepository } from '@/src/infrastructure/repositories/recurring-task-item/IRecurringTaskItemRepository';
import type { ITaskRepository } from '@/src/infrastructure/repositories/task/ITaskRepository';
import { logger } from '@/src/shared/logging';
import { MutateRecurringTaskItemResponse } from './types';

/**
 * Updates a recurring task item.
 *
 * This use case:
 * 1. Verifies the recurring item exists and belongs to the user
 * 2. Updates the recurring item via repository
 * 3. If isActive is changed to false, cleans up future uncompleted tasks
 * 4. If recurrence parameters are updated, regenerates all tasks by deleting uncompleted tasks and resetting lastGeneratedDate
 * 5. If task template fields are updated, syncs changes to uncompleted tasks
 *
 * @param recurringItemId - The ID of the recurring item to update
 * @param userId - The ID of the user performing the update
 * @param updates - The fields to update
 * @param recurringRepository - Repository for recurring task items
 * @param taskRepository - Repository for tasks
 * @returns Response with the updated recurring item
 */
export async function updateRecurringTaskItem(
  recurringItemId: string,
  userId: string,
  updates: UpdateRecurringTaskItemInput,
  recurringRepository: IRecurringTaskItemRepository,
  taskRepository: ITaskRepository
): Promise<MutateRecurringTaskItemResponse> {
  try {
    // Verify recurring item exists and belongs to user
    const existingItem = await recurringRepository.getById(recurringItemId);

    if (!existingItem) {
      logger.error('Recurring task item not found', { recurringItemId });
      return { success: false, error: 'Recurring task item not found' };
    }

    if (existingItem.userId !== userId) {
      logger.error('Recurring task item does not belong to user', {
        recurringItemId,
        userId,
      });
      return { success: false, error: 'Recurring task item not found' };
    }

    // Check if isActive is being changed to false
    const isDeactivating =
      updates.isActive === false && existingItem.isActive === true;

    // Check if endDate is being updated
    // This is the only recurrence parameter that can be changed after creation
    // When endDate changes, the RRULE string is regenerated by the repository
    const hasRecurrenceParameterUpdates = updates.endDate !== undefined;

    // Identify which task template fields are being updated
    // These fields are copied to generated tasks and should be synced to existing uncompleted tasks
    const taskTemplateFields: (keyof UpdateRecurringTaskItemInput)[] = [
      'title',
      'description',
      'categoryId',
      'priority',
      'dailySection',
      'bonusSection',
    ];

    const hasTaskTemplateUpdates = taskTemplateFields.some(
      (field) => updates[field] !== undefined
    );

    // Update the recurring item
    const updatedItem = await recurringRepository.update(
      recurringItemId,
      updates
    );

    // If deactivating, clean up future uncompleted tasks
    if (isDeactivating) {
      await taskRepository.deleteUncompletedByRecurringItemId(recurringItemId);
    } else if (hasRecurrenceParameterUpdates) {
      // Regenerate tasks when recurrence parameters change
      // Delete all uncompleted tasks and reset lastGeneratedDate to trigger regeneration
      await taskRepository.deleteUncompletedByRecurringItemId(recurringItemId);
      await recurringRepository.updateLastGeneratedDate(recurringItemId, null);
    } else if (hasTaskTemplateUpdates) {
      // Sync task template field changes to uncompleted tasks
      const taskUpdates: Partial<Task> = {};

      if (updates.title !== undefined) {
        taskUpdates.title = updates.title;
      }
      if (updates.description !== undefined) {
        taskUpdates.description = updates.description ?? null;
      }
      if (updates.categoryId !== undefined) {
        taskUpdates.categoryId = updates.categoryId ?? null;
      }
      if (updates.priority !== undefined) {
        taskUpdates.priority = updates.priority ?? null;
      }
      if (updates.dailySection !== undefined) {
        taskUpdates.dailySection = updates.dailySection ?? null;
      }
      if (updates.bonusSection !== undefined) {
        taskUpdates.bonusSection = updates.bonusSection ?? null;
      }

      await taskRepository.bulkUpdateUncompletedByRecurringItemId(
        recurringItemId,
        taskUpdates
      );
    }

    return {
      success: true,
      recurringItem: updatedItem,
    };
  } catch (error) {
    logger.error('Update recurring task item error', { error });
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : 'Failed to update recurring task item',
    };
  }
}
