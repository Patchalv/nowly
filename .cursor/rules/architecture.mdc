---
description: Clean Architecture enforcement and patterns for Nowly
globs: *.ts,*.tsx
alwaysApply: true
---

# Architecture Guidelines for Nowly

## ğŸ¯ Core Principles

- **Dependency Rule** - Dependencies point inward only: presentation â†’ application â†’ domain
- **Layer Isolation** - Each layer has clear responsibilities and boundaries
- **Framework Independence** - Domain and application layers have no framework dependencies
- **Testability** - Business logic testable without UI, database, or frameworks

---

## ğŸ“ Layer Structure

```
app/                    # Next.js routing & Server Components
src/
â”œâ”€â”€ presentation/       # UI components, hooks, providers (React/Next.js)
â”œâ”€â”€ application/        # Use cases (business logic)
â”œâ”€â”€ domain/            # Entities, types, validation (pure TypeScript)
â”œâ”€â”€ infrastructure/    # Supabase, repositories, external services
â”œâ”€â”€ config/            # Environment variables, constants
â””â”€â”€ shared/            # Common utilities, types
```

---

## ğŸ”’ Dependency Rules

### What Each Layer Can Import

```typescript
// âœ… Domain - NOTHING (pure TypeScript)
// No imports from other layers

// âœ… Application - domain only
import type { Entity } from "@/src/domain/models/Entity";
import { entitySchema } from "@/src/domain/validation/entity.schema";

// âœ… Infrastructure - domain, application
import type { Entity } from "@/src/domain/models/Entity";
import type { EntityRepository } from "@/src/infrastructure/repositories/IEntityRepository";

// âœ… Presentation - application, domain (NOT infrastructure)
import { createEntity } from "@/src/application/entities/createEntity.usecase";
import type { Entity } from "@/src/domain/models/Entity";

// âŒ Presentation CANNOT import infrastructure
import { SupabaseEntityRepository } from "@/src/infrastructure/repositories/SupabaseEntityRepository"; // WRONG!
```

### Dependency Flow

```
presentation (React/Next.js)
      â†“
application (use cases)
      â†“
domain (entities, validation)
      â†‘
infrastructure (Supabase, repos)
```

---

## ğŸ—ï¸ Domain Layer

**Purpose:** Pure business entities and rules  
**Location:** `src/domain/`  
**Dependencies:** NONE (pure TypeScript)

### Structure

```
domain/
â”œâ”€â”€ models/              # Entity definitions
â”‚   â”œâ”€â”€ Task.ts
â”‚   â””â”€â”€ Category.ts
â”œâ”€â”€ types/              # Enums, value objects
â”‚   â””â”€â”€ index.ts
â””â”€â”€ validation/         # Zod schemas
    â””â”€â”€ task.schema.ts
```

### Domain Entity Pattern

```typescript
// src/domain/models/Task.ts
export interface Task {
  id: string;
  userId: string;
  title: string;
  completed: boolean;
  createdAt: Date;
  updatedAt: Date;
}
```

### Domain Types Pattern

```typescript
// src/domain/types/index.ts
export type Priority = "high" | "medium" | "low";
export type Status = "active" | "inactive";
```

### Domain Validation Pattern

```typescript
// src/domain/validation/task.schema.ts
import { z } from "zod";

export const createTaskSchema = z.object({
  title: z.string().min(1).max(255),
  priority: z.enum(["high", "medium", "low"]).optional(),
});

export type CreateTaskInput = z.infer<typeof createTaskSchema>;
```

**Rules:**

- âœ… No framework imports (React, Next.js, Supabase)
- âœ… Only pure TypeScript types and interfaces
- âœ… Zod for validation (allowed as it's pure)
- âŒ No database types (snake_case, ISO strings)
- âŒ No UI concerns

---

## ğŸ’¼ Application Layer

**Purpose:** Business logic and use cases  
**Location:** `src/application/`  
**Dependencies:** domain only

### Structure

```
application/
â”œâ”€â”€ tasks/
â”‚   â”œâ”€â”€ createTask.usecase.ts
â”‚   â”œâ”€â”€ updateTask.usecase.ts
â”‚   â””â”€â”€ listTasks.usecase.ts
â””â”€â”€ categories/
    â””â”€â”€ createCategory.usecase.ts
```

### Use Case Pattern

```typescript
// src/application/tasks/createTask.usecase.ts
import type { Task } from "@/src/domain/models/Task";
import type { CreateTaskInput } from "@/src/domain/validation/task.schema";
import type { TaskRepository } from "@/src/infrastructure/repositories/ITaskRepository";

export interface CreateTaskRequest {
  title: string;
  priority?: "high" | "medium" | "low";
}

export interface CreateTaskResponse {
  task: Task;
  success: boolean;
  error?: string;
}

export async function createTask(
  request: CreateTaskRequest,
  userId: string,
  repository: TaskRepository
): Promise<CreateTaskResponse> {
  try {
    const task = await repository.create({
      ...request,
      userId,
      completed: false,
    });

    return { success: true, task };
  } catch (error) {
    return {
      success: false,
      error: "Failed to create task",
      task: null as any,
    };
  }
}
```

**Rules:**

- âœ… Pure business logic only
- âœ… Accept repositories as parameters (dependency injection)
- âœ… Return domain entities
- âœ… Use Request/Response types
- âŒ No direct Supabase client usage
- âŒ No React hooks or components
- âŒ No database-specific logic

---

## ğŸ—„ï¸ Infrastructure Layer

**Purpose:** External services, database, repositories  
**Location:** `src/infrastructure/`  
**Dependencies:** domain, application

### Structure

```
infrastructure/
â”œâ”€â”€ supabase/
â”‚   â”œâ”€â”€ client.ts           # Supabase client setup
â”‚   â””â”€â”€ types.ts            # Database types (snake_case)
â””â”€â”€ repositories/
    â”œâ”€â”€ ITaskRepository.ts  # Interface (domain-focused)
    â””â”€â”€ SupabaseTaskRepository.ts  # Implementation
```

### Repository Interface Pattern

```typescript
// src/infrastructure/repositories/ITaskRepository.ts
import type { Task } from "@/src/domain/models/Task";

export interface TaskRepository {
  create(task: Omit<Task, "id" | "createdAt" | "updatedAt">): Promise<Task>;
  findById(id: string): Promise<Task | null>;
  findByUserId(userId: string): Promise<Task[]>;
  update(id: string, updates: Partial<Task>): Promise<Task>;
  delete(id: string): Promise<void>;
}
```

### Repository Implementation Pattern

```typescript
// src/infrastructure/repositories/SupabaseTaskRepository.ts
import type { SupabaseClient } from "@supabase/supabase-js";
import type { TaskRepository } from "./ITaskRepository";
import type { Task } from "@/src/domain/models/Task";
import type { TaskRow } from "../supabase/types";

export class SupabaseTaskRepository implements TaskRepository {
  constructor(private client: SupabaseClient) {}

  private toDomain(row: TaskRow): Task {
    return {
      id: row.id,
      userId: row.user_id,
      title: row.title,
      completed: row.completed,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    };
  }

  private toDatabase(task: Partial<Task>): Partial<TaskRow> {
    return {
      user_id: task.userId,
      title: task.title,
      completed: task.completed,
    };
  }

  async create(
    task: Omit<Task, "id" | "createdAt" | "updatedAt">
  ): Promise<Task> {
    const { data, error } = await this.client
      .from("tasks")
      .insert(this.toDatabase(task))
      .select()
      .single();

    if (error) throw new Error(`Failed to create task: ${error.message}`);
    return this.toDomain(data);
  }

  async findByUserId(userId: string): Promise<Task[]> {
    const { data, error } = await this.client
      .from("tasks")
      .select("*")
      .eq("user_id", userId);

    if (error) throw new Error(`Failed to fetch tasks: ${error.message}`);
    return data.map((row) => this.toDomain(row));
  }
}
```

**Rules:**

- âœ… Transform between database types (snake_case) and domain types (camelCase)
- âœ… Repository methods return domain entities
- âœ… Handle all database-specific logic here
- âœ… Implement repository interfaces
- âŒ Don't expose database types outside this layer
- âŒ Don't put business logic in repositories

---

## ğŸ¨ Presentation Layer

**Purpose:** UI components, hooks, and React/Next.js specific code  
**Location:** `src/presentation/`, `app/`  
**Dependencies:** application, domain (NOT infrastructure)

### Structure

```
presentation/
â”œâ”€â”€ components/         # React components
â”‚   â”œâ”€â”€ TaskCard.tsx
â”‚   â””â”€â”€ TaskList.tsx
â”œâ”€â”€ hooks/             # Custom React hooks
â”‚   â””â”€â”€ useTasks.ts
â””â”€â”€ providers/         # React context providers
    â””â”€â”€ QueryProvider.tsx

app/                   # Next.js App Router
â”œâ”€â”€ (protected)/       # Protected routes
â”‚   â””â”€â”€ tasks/
â”‚       â””â”€â”€ page.tsx   # Server Component
â””â”€â”€ actions/           # Server Actions
    â””â”€â”€ createTaskAction.ts
```

### Server Component Pattern

```typescript
// app/(protected)/tasks/page.tsx
import { createServerClient } from "@/src/infrastructure/supabase/client";
import { SupabaseTaskRepository } from "@/src/infrastructure/repositories/SupabaseTaskRepository";
import { TaskList } from "@/src/presentation/components/TaskList";

export default async function TasksPage() {
  const supabase = createServerClient();
  const repository = new SupabaseTaskRepository(supabase);

  const tasks = await repository.findByUserId("user-id");

  return <TaskList tasks={tasks} />;
}
```

### Client Component Pattern

```typescript
// src/presentation/components/TaskCard.tsx
"use client";

import type { Task } from "@/src/domain/models/Task";

interface TaskCardProps {
  task: Task;
  onToggle: (id: string) => void;
}

export function TaskCard({ task, onToggle }: TaskCardProps) {
  return (
    <div onClick={() => onToggle(task.id)}>
      <h3>{task.title}</h3>
    </div>
  );
}
```

### React Query Hook Pattern

```typescript
// src/presentation/hooks/useTasks.ts
"use client";

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { createTask } from "@/src/application/tasks/createTask.usecase";
import type { CreateTaskRequest } from "@/src/application/tasks/createTask.usecase";

export function useCreateTask() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (request: CreateTaskRequest) => {
      // Repository injected here (presentation layer responsibility)
      const repository = getTaskRepository(); // Helper function
      return createTask(request, "user-id", repository);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["tasks"] });
    },
  });
}
```

### Server Action Pattern

```typescript
// app/actions/createTaskAction.ts
"use server";

import { revalidatePath } from "next/cache";
import { createTask } from "@/src/application/tasks/createTask.usecase";
import { createTaskSchema } from "@/src/domain/validation/task.schema";
import { createServerClient } from "@/src/infrastructure/supabase/client";
import { SupabaseTaskRepository } from "@/src/infrastructure/repositories/SupabaseTaskRepository";

export async function createTaskAction(formData: FormData) {
  const result = createTaskSchema.safeParse({
    title: formData.get("title"),
  });

  if (!result.success) {
    return { success: false, errors: result.error.flatten().fieldErrors };
  }

  const supabase = createServerClient();
  const repository = new SupabaseTaskRepository(supabase);

  const response = await createTask(result.data, "user-id", repository);

  if (response.success) {
    revalidatePath("/tasks");
  }

  return response;
}
```

**Rules:**

- âœ… Server Components can instantiate repositories directly
- âœ… Client Components use hooks that abstract repository access
- âœ… Server Actions handle repository instantiation
- âœ… Import from application and domain layers
- âŒ NEVER import infrastructure repositories in Client Components
- âŒ Don't put business logic in components

---

## ğŸ”„ Data Flow Examples

### Creating a Task (Client Component)

```
User Form Input
      â†“
TaskForm Component (presentation)
      â†“
useCreateTask Hook (presentation)
      â†“
createTask Use Case (application)
      â†“
TaskRepository Interface (infrastructure)
      â†“
SupabaseTaskRepository (infrastructure)
      â†“
Supabase Database
```

### Creating a Task (Server Action)

```
Form Submission
      â†“
createTaskAction (Server Action in app/actions)
      â†“
Validation (domain schema)
      â†“
createTask Use Case (application)
      â†“
SupabaseTaskRepository (infrastructure)
      â†“
Supabase Database
      â†“
revalidatePath (Next.js)
```

### Fetching Tasks (Server Component)

```
TasksPage (Server Component in app)
      â†“
SupabaseTaskRepository (infrastructure)
      â†“
Supabase Database
      â†“
Domain Entities (Task[])
      â†“
TaskList Component (presentation)
```

---

## ğŸ§ª Testing Strategy

### Domain Layer Tests

```typescript
// Pure unit tests - no mocks needed
import { createTaskSchema } from "@/src/domain/validation/task.schema";

describe("createTaskSchema", () => {
  it("should validate valid task data", () => {
    const result = createTaskSchema.safeParse({ title: "Test" });
    expect(result.success).toBe(true);
  });
});
```

### Application Layer Tests

```typescript
// Test use cases with mock repositories
import { createTask } from "@/src/application/tasks/createTask.usecase";
import type { TaskRepository } from "@/src/infrastructure/repositories/ITaskRepository";

describe("createTask", () => {
  it("should create a task", async () => {
    const mockRepo: TaskRepository = {
      create: vi.fn().mockResolvedValue({ id: "1", title: "Test" }),
      // ... other methods
    };

    const result = await createTask({ title: "Test" }, "user-id", mockRepo);

    expect(result.success).toBe(true);
    expect(mockRepo.create).toHaveBeenCalled();
  });
});
```

### Infrastructure Layer Tests

```typescript
// Integration tests with real database (or test database)
import { SupabaseTaskRepository } from "@/src/infrastructure/repositories/SupabaseTaskRepository";

describe("SupabaseTaskRepository", () => {
  it("should create and retrieve a task", async () => {
    const repo = new SupabaseTaskRepository(testClient);
    const task = await repo.create({ title: "Test", userId: "user-1" });
    const found = await repo.findById(task.id);

    expect(found).toEqual(task);
  });
});
```

---

## ğŸš« Common Violations

### âŒ Importing Infrastructure in Presentation (Client)

```typescript
// âŒ BAD - Client Component directly importing repository
"use client";
import { SupabaseTaskRepository } from "@/src/infrastructure/repositories/SupabaseTaskRepository";

export function TaskList() {
  const repo = new SupabaseTaskRepository(); // WRONG!
}
```

### âœ… Correct Approach

```typescript
// âœ… GOOD - Use hook that abstracts repository access
"use client";
import { useTasks } from "@/src/presentation/hooks/useTasks";

export function TaskList() {
  const { data: tasks } = useTasks();
}
```

### âŒ Business Logic in Component

```typescript
// âŒ BAD - Business logic in component
export function TaskForm() {
  const onSubmit = (data: TaskInput) => {
    if (data.dueDate < data.scheduledDate) {
      // Business rule
      setError("Invalid dates");
    }
  };
}
```

### âœ… Correct Approach

```typescript
// âœ… GOOD - Business logic in domain validation
export const createTaskSchema = z
  .object({
    scheduledDate: z.date(),
    dueDate: z.date(),
  })
  .refine((data) => data.dueDate >= data.scheduledDate, {
    message: "Due date must be after scheduled date",
  });
```

### âŒ Domain Types with Framework Dependencies

```typescript
// âŒ BAD - Domain type with React dependency
import type { ReactNode } from "react";

export interface Task {
  id: string;
  title: ReactNode; // WRONG!
}
```

### âœ… Correct Approach

```typescript
// âœ… GOOD - Pure TypeScript
export interface Task {
  id: string;
  title: string;
}
```

---

## ğŸ” Authentication Layer Patterns

### Authentication Architecture

Authentication follows strict layer separation with Server Actions as the primary interface:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Presentation Layer (Client Components)             â”‚
â”‚  â€¢ Auth Forms (Login, Signup, Reset)                â”‚
â”‚  â€¢ Submit to Server Actions only                    â”‚
â”‚  â€¢ Display errors and loading states                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Application Layer (Server Actions)                 â”‚
â”‚  â€¢ app/actions/*Action.ts                           â”‚
â”‚  â€¢ Validate input with domain schemas               â”‚
â”‚  â€¢ Call infrastructure auth services                â”‚
â”‚  â€¢ Return success/error results                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Infrastructure Layer (Supabase Auth)               â”‚
â”‚  â€¢ Server-side Supabase client                      â”‚
â”‚  â€¢ Auth confirmation handler (/auth/confirm)        â”‚
â”‚  â€¢ Session management (middleware)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Server Action Pattern for Auth

```typescript
// app/actions/authAction.ts
'use server';

import { createClient } from '@/src/infrastructure/supabase/server';
import { authSchema } from '@/src/domain/validation/auth.schema';
import { redirect } from 'next/navigation';

type AuthActionResult =
  | { success: true }
  | { success: false; error: string; fieldErrors?: Record<string, string[]> };

export async function authAction(
  formData: FormData
): Promise<AuthActionResult> {
  // 1. Validate with domain schema
  const result = authSchema.safeParse({
    email: formData.get('email'),
  });
  
  if (!result.success) {
    return {
      success: false,
      error: 'Invalid input',
      fieldErrors: result.error.flatten().fieldErrors,
    };
  }
  
  // 2. Use server Supabase client
  const supabase = await createClient();
  
  // 3. Perform auth operation
  const { error } = await supabase.auth.someOperation(result.data);
  
  if (error) {
    return { success: false, error: 'User-friendly message' };
  }
  
  // 4. Redirect on success (throws)
  redirect('/destination');
}
```

### Form Component Pattern for Auth

```typescript
// src/presentation/components/authentication/AuthForm.tsx
'use client';

import { authAction } from '@/app/actions/authAction';
import { authSchema, type AuthFormData } from '@/src/domain/validation/auth.schema';
import { useTransition } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { toast } from 'sonner';

export function AuthForm() {
  const [isPending, startTransition] = useTransition();
  
  const form = useForm<AuthFormData>({
    resolver: zodResolver(authSchema),
  });
  
  const onSubmit = async (data: AuthFormData) => {
    startTransition(async () => {
      const formData = new FormData();
      Object.entries(data).forEach(([key, value]) => {
        formData.append(key, value);
      });
      
      const result = await authAction(formData);
      
      if (!result.success) {
        toast.error('Operation failed', { description: result.error });
      }
    });
  };
  
  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Form fields */}
    </form>
  );
}
```

### Email Confirmation Pattern

All email links (password reset, email confirmation) must use server-side token exchange:

```typescript
// app/auth/confirm/route.ts
import { type EmailOtpType } from '@supabase/supabase-js';
import { createClient } from '@/src/infrastructure/supabase/server';
import { redirect } from 'next/navigation';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const token_hash = searchParams.get('token_hash');
  const type = searchParams.get('type') as EmailOtpType | null;
  const next = searchParams.get('next') ?? '/';
  
  if (token_hash && type) {
    const supabase = await createClient();
    const { error } = await supabase.auth.verifyOtp({ type, token_hash });
    
    if (!error) {
      redirect(next);
    }
  }
  
  redirect('/error');
}
```

### Authentication Rules

**âœ… DO:**
- Use Server Actions for all auth form submissions
- Validate with Zod schemas in both client and server
- Use `createClient()` from server module in Server Actions
- Use `supabase.auth.getUser()` for session verification
- Return typed results from Server Actions
- Provide user-friendly error messages
- Use `useTransition` for loading states
- Redirect after successful auth operations

**âŒ DON'T:**
- Call auth utilities directly from client components
- Use browser Supabase client in Server Actions
- Use `supabase.auth.getSession()` on server (not verified)
- Exchange PKCE tokens client-side
- Expose detailed error messages (security risk)
- Skip server-side validation
- Trust client input without validation

### Session Management

The proxy middleware handles session management automatically:

```typescript
// proxy.ts
export async function proxy(request: NextRequest) {
  const supabase = createServerClient(/* config */);
  
  // Automatically refreshes expired sessions
  const { data: { user } } = await supabase.auth.getUser();
  
  // Protect routes
  if (!isPublicRoute && !user) {
    return NextResponse.redirect('/login');
  }
  
  return response;
}
```

**Server Components** can access user directly:

```typescript
// app/(protected)/page.tsx
import { createClient } from '@/src/infrastructure/supabase/server';

export default async function ProtectedPage() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  
  if (!user) {
    redirect('/login');
  }
  
  return <div>Welcome {user.email}</div>;
}
```

---

## ğŸ“‹ Architecture Checklist

Before committing code:

### Domain Layer

- [ ] No framework imports (React, Next.js, Supabase)
- [ ] Only pure TypeScript types and interfaces
- [ ] No references to database types (snake_case, ISO strings)
- [ ] Validation schemas use Zod

### Application Layer

- [ ] Use cases accept repositories as parameters
- [ ] Return domain entities, not database types
- [ ] No direct Supabase client usage
- [ ] No React/Next.js specific code
- [ ] Server Actions use server Supabase client
- [ ] Server Actions validate with Zod schemas
- [ ] Server Actions return typed results

### Infrastructure Layer

- [ ] Repositories implement interfaces
- [ ] Transform data at boundary (toDomain/toDatabase)
- [ ] Return domain entities from repository methods
- [ ] No business logic in repositories

### Presentation Layer

- [ ] Server Components can instantiate repositories
- [ ] Client Components use hooks (no direct repository imports)
- [ ] Server Actions handle repository instantiation
- [ ] No business logic in components
- [ ] Import from application/domain only (not infrastructure repositories)
- [ ] Auth forms use Server Actions (not client utilities)
- [ ] Forms use useTransition for pending states

---

## ğŸ¯ Quick Reference

**When to use each layer:**

- **Domain** - Define entities, types, validation schemas
- **Application** - Implement business logic and use cases
- **Infrastructure** - Database access, external APIs, repository implementations
- **Presentation** - UI components, hooks, Server Components, Server Actions

**Key Rule:** Arrows point inward. Outer layers depend on inner layers, never the reverse.

**Auth-Specific Rule:** All auth operations use Server Actions. No client-side auth utilities for form submissions.
