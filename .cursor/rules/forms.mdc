---
description: Form handling patterns with React Hook Form and Zod for Nowly
globs: *.tsx,*Form.tsx,*.schema.ts
alwaysApply: true
---

# Form Guidelines for Nowly

## üéØ Core Principles

- **Zod schemas for validation** - Single source of truth in domain layer
- **React Hook Form for state** - Performant, minimal re-renders
- **Type-safe** - Infer types from Zod schemas
- **Server Actions** - Leverage Next.js App Router
- **Accessible** - Proper labels, ARIA attributes, error messages

---

## üîß Standard Form Pattern

### 1. Define Zod Schema (Domain Layer)

```typescript
// src/domain/validation/entity.schema.ts
import { z } from "zod";

export const createEntitySchema = z.object({
  title: z.string().min(1, "Title is required").max(255),
  description: z.string().max(5000).optional(),
  date: z.date().optional(),
  priority: z.enum(["high", "medium", "low"]).optional(),
});

export type CreateEntityInput = z.infer<typeof createEntitySchema>;
```

### 2. Create Form Component (Presentation Layer)

```typescript
// src/presentation/components/CreateEntityForm.tsx
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  createEntitySchema,
  type CreateEntityInput,
} from "@/src/domain/validation/entity.schema";

export function CreateEntityForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset,
  } = useForm<CreateEntityInput>({
    resolver: zodResolver(createEntitySchema),
    defaultValues: { title: "", description: "" },
  });

  const onSubmit = async (data: CreateEntityInput) => {
    // Handle submission
    reset();
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <label htmlFor="title" className="block text-sm font-medium">
          Title
        </label>
        <input
          {...register("title")}
          id="title"
          type="text"
          className="mt-1 block w-full rounded-md border p-2"
          aria-invalid={errors.title ? "true" : "false"}
        />
        {errors.title && (
          <p className="mt-1 text-sm text-red-600" role="alert">
            {errors.title.message}
          </p>
        )}
      </div>

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Submitting..." : "Submit"}
      </button>
    </form>
  );
}
```

---

## üìã Common Input Patterns

### Select Dropdown

```typescript
<select {...register("priority")} id="priority">
  <option value="">Select...</option>
  <option value="high">High</option>
  <option value="medium">Medium</option>
  <option value="low">Low</option>
</select>
```

### Checkbox

```typescript
<input {...register("completed")} type="checkbox" id="completed" />
```

### Date with Controller

```typescript
import { Controller } from "react-hook-form";

<Controller
  name="date"
  control={control}
  render={({ field }) => (
    <input
      type="date"
      value={field.value ? field.value.toISOString().split("T")[0] : ""}
      onChange={(e) =>
        field.onChange(e.target.value ? new Date(e.target.value) : undefined)
      }
    />
  )}
/>;
```

### Radio Buttons

```typescript
{
  ["morning", "afternoon", "evening"].map((section) => (
    <div key={section}>
      <input
        {...register("dailySection")}
        type="radio"
        value={section}
        id={section}
      />
      <label htmlFor={section}>{section}</label>
    </div>
  ));
}
```

---

## üé® Shadcn/UI Integration

```typescript
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";

export function CreateEntityForm() {
  const form = useForm<CreateEntityInput>({
    resolver: zodResolver(createEntitySchema),
  });

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Title</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </form>
    </Form>
  );
}
```

---

## üöÄ Server Actions

### FormData Actions (Form Submissions)

```typescript
// app/actions/createEntityAction.ts
"use server";

import { revalidatePath } from "next/cache";
import { createEntitySchema } from "@/src/domain/validation/entity.schema";

export async function createEntityAction(formData: FormData) {
  const result = createEntitySchema.safeParse({
    title: formData.get("title"),
    description: formData.get("description") || undefined,
  });

  if (!result.success) {
    return { success: false, errors: result.error.flatten().fieldErrors };
  }

  // Execute use case
  await createEntity(result.data);

  revalidatePath("/dashboard");
  return { success: true };
}
```

```typescript
// Using in component
"use client";

import { useTransition } from "react";
import { toast } from "sonner";

export function CreateEntityForm() {
  const [isPending, startTransition] = useTransition();

  const onSubmit = async (data: CreateEntityInput) => {
    const formData = new FormData();
    Object.entries(data).forEach(([key, value]) => {
      if (value !== undefined) formData.append(key, String(value));
    });

    startTransition(async () => {
      const result = await createEntityAction(formData);
      if (result.success) {
        toast.success("Created successfully");
      } else {
        toast.error("Failed to create");
      }
    });
  };
}
```

### Non-FormData Actions (Query/Fetch Actions)

**Critical**: Next.js server actions serialize parameters when crossing the client-server boundary. Date objects become ISO strings, and complex objects are serialized. Always validate and coerce inputs at the server action boundary.

#### Date Parameter Validation

```typescript
// app/actions/getTasksAction.ts
"use server";
import { z } from "zod";
import { isValidDate } from "@/src/shared/utils/date";

// Date schema - handles serialized Date strings from client
const dateInputSchema = z
  .union([z.string(), z.date()]) // Accept both string (serialized) and Date
  .transform((val) => {
    if (val instanceof Date) return val;
    const parsed = new Date(val);
    if (isNaN(parsed.getTime())) {
      throw new z.ZodError([
        {
          code: "custom",
          path: [],
          message: "Invalid date format",
        },
      ]);
    }
    return parsed;
  })
  .pipe(
    z.date().refine((date) => isValidDate(date), {
      message: "Invalid date",
    })
  );

export async function getTasksAction(date: Date | string) {
  // Validate input
  const dateResult = dateInputSchema.safeParse(date);
  if (!dateResult.success) {
    logger.error("Get tasks validation error", { error: dateResult.error });
    return {
      success: false,
      error: "Invalid date format",
      tasks: [],
      errors: dateResult.error.flatten().fieldErrors,
    };
  }

  const validatedDate = dateResult.data;

  // Continue with validated date...
  const response = await listTasksByDate(userId, validatedDate, repository);
  return response;
}
```

#### Object Parameter Validation

```typescript
// app/actions/listTasksAction.ts
"use server";
import { z } from "zod";

// Define validation schema matching the expected object structure
const taskFiltersSchema = z.object({
  categoryId: z.string().uuid().nullable().optional(),
  showCompleted: z.enum(["IsCompleted", "IsNotCompleted", "All"]),
  showScheduled: z.enum(["IsScheduled", "IsNotScheduled", "All"]),
  search: z.string().optional(),
});

const pageSchema = z.number().int().min(1).default(1);

export async function listTasksAction(
  filters: TaskFilters,
  page: number
) {
  // Validate inputs
  const filtersResult = taskFiltersSchema.safeParse(filters);
  const pageResult = pageSchema.safeParse(page);

  if (!filtersResult.success) {
    logger.error("List tasks filters validation error", {
      error: filtersResult.error,
    });
    return {
      success: false,
      error: "Invalid filters format",
      tasks: [],
      errors: filtersResult.error.flatten().fieldErrors,
    };
  }

  if (!pageResult.success) {
    logger.error("List tasks page validation error", {
      error: pageResult.error,
    });
    return {
      success: false,
      error: "Invalid page number",
      tasks: [],
      errors: pageResult.error.flatten().fieldErrors,
    };
  }

  const validatedFilters = filtersResult.data;
  const validatedPage = pageResult.data;

  // Continue with validated inputs...
  const response = await findByUserIdAndFilters(
    userId,
    validatedFilters,
    validatedPage,
    repository
  );
  return response;
}
```

#### Validation Best Practices

**1. Always validate at server action boundary**

- ‚úÖ Validate immediately after function parameters
- ‚úÖ Before any authentication or business logic
- ‚úÖ Use `safeParse` to handle errors gracefully

**2. Handle Next.js serialization**

- ‚úÖ Accept `Date | string` for date parameters (reflects serialization reality)
- ‚úÖ Use Zod transforms to coerce strings to Date objects
- ‚úÖ Validate object structures match expected types

**3. Consistent error responses**

```typescript
// Standard error response format
{
  success: false,
  error: string, // User-friendly message
  tasks: [], // Empty array/appropriate default
  errors?: Record<string, string[]>, // Field-level errors
}
```

**4. Log validation errors**

```typescript
if (!result.success) {
  logger.error("Action validation error", { error: result.error });
  return {
    success: false,
    error: "Invalid input format",
    // ... rest of error response
  };
}
```

**5. Type signatures reflect reality**

```typescript
// ‚úÖ Good - reflects Next.js serialization
export async function getTasksAction(date: Date | string)

// ‚ùå Bad - doesn't match runtime behavior
export async function getTasksAction(date: Date)
```

#### Common Validation Patterns

**Date validation with coercion:**
```typescript
const dateInputSchema = z
  .union([z.string(), z.date()])
  .transform((val) => {
    if (val instanceof Date) return val;
    const parsed = new Date(val);
    if (isNaN(parsed.getTime())) {
      throw new z.ZodError([{
        code: "custom",
        path: [],
        message: "Invalid date format",
      }]);
    }
    return parsed;
  })
  .pipe(z.date().refine((date) => isValidDate(date)));
```

**Number validation:**
```typescript
const pageSchema = z.number().int().min(1).default(1);
```

**Enum validation:**
```typescript
const statusSchema = z.enum(["active", "inactive", "pending"]);
```

**Optional UUID:**
```typescript
const categoryIdSchema = z.string().uuid().nullable().optional();
```

---

## ‚ö° Optimistic Updates with React Query

```typescript
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";

export function UpdateEntityForm({ entity }: { entity: Entity }) {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: (data: UpdateEntityInput) => updateEntity(entity.id, data),
    onMutate: async (newData) => {
      await queryClient.cancelQueries({
        queryKey: entityKeys.detail(entity.id),
      });
      const previous = queryClient.getQueryData(entityKeys.detail(entity.id));
      queryClient.setQueryData(entityKeys.detail(entity.id), {
        ...entity,
        ...newData,
      });
      return { previous };
    },
    onError: (err, vars, context) => {
      queryClient.setQueryData(entityKeys.detail(entity.id), context?.previous);
      toast.error("Update failed");
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: entityKeys.detail(entity.id) });
      toast.success("Updated successfully");
    },
  });

  const form = useForm<UpdateEntityInput>({
    resolver: zodResolver(updateEntitySchema),
    defaultValues: entity,
  });

  return (
    <form onSubmit={form.handleSubmit((data) => mutation.mutate(data))}>
      {/* fields */}
    </form>
  );
}
```

---

## ‚úÖ Advanced Zod Patterns

### Conditional Validation

```typescript
z.object({
  scheduledDate: z.date().optional(),
  dueDate: z.date().optional(),
}).refine(
  (data) =>
    !data.dueDate || !data.scheduledDate || data.dueDate >= data.scheduledDate,
  { message: "Due date must be after scheduled date", path: ["dueDate"] }
);
```

### Transform Data

```typescript
z.object({
  title: z.string().transform((val) => val.trim()),
  tags: z.string().transform((val) => val.split(",").map((t) => t.trim())),
});
```

### Array Validation

```typescript
z.object({
  daysOfWeek: z
    .array(z.enum(["mon", "tue", "wed", "thu", "fri", "sat", "sun"]))
    .min(1, "Select at least one day"),
});
```

---

## üéØ Form State Management

```typescript
const { watch, setValue, reset, trigger } = useForm<FormInput>();

// Watch field
const title = watch("title");

// Set value
setValue("title", "New Title", { shouldValidate: true });

// Reset form
reset(); // or reset({ title: 'New Title' });

// Manual validation
await trigger("title"); // single field
await trigger(); // all fields
```

### Conditional Fields

```typescript
const hasRecurrence = watch("hasRecurrence");

return (
  <form>
    <input {...register("hasRecurrence")} type="checkbox" />
    {hasRecurrence && <select {...register("frequency")}>{/* ... */}</select>}
  </form>
);
```

---

## üîç Validation Modes

```typescript
// Validate on blur (recommended for most forms)
useForm({ resolver: zodResolver(schema), mode: "onBlur" });

// Validate on change (expensive, use sparingly)
useForm({ resolver: zodResolver(schema), mode: "onChange" });

// Validate on submit (default)
useForm({ resolver: zodResolver(schema), mode: "onSubmit" });
```

---

## ‚ôø Accessibility Requirements

Every field must have:

- ‚úÖ `<label>` with matching `htmlFor` and `id`
- ‚úÖ `aria-invalid={errors.field ? 'true' : 'false'}`
- ‚úÖ Error message with `role="alert"`
- ‚úÖ Unique error `id` referenced by `aria-describedby` (optional but recommended)

```typescript
<label htmlFor="title">Title</label>
<input
  {...register('title')}
  id="title"
  aria-invalid={errors.title ? 'true' : 'false'}
  aria-describedby={errors.title ? 'title-error' : undefined}
/>
{errors.title && (
  <p id="title-error" role="alert">
    {errors.title.message}
  </p>
)}
```

---

## üö´ Anti-Patterns

- ‚ùå Validating in multiple places (Zod + component logic)
- ‚ùå Using uncontrolled inputs without `{...register()}`
- ‚ùå Not displaying error messages
- ‚ùå Bypassing `handleSubmit` for form submission
- ‚ùå Missing labels for inputs
- ‚ùå Not handling loading states

---

## üìã Form Checklist

- [ ] Zod schema in domain validation layer
- [ ] Type inferred from schema
- [ ] All fields registered or controlled
- [ ] Labels associated with inputs
- [ ] Errors displayed with `role="alert"`
- [ ] Submit button disabled during submission
- [ ] Accessibility attributes added
- [ ] Success/error feedback shown (toast)
- [ ] Form reset after success (if appropriate)
